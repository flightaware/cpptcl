<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>C++/Tcl</title>
</head>
<body>
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="20">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><font size="+3"><span
 style="font-family: helvetica,arial,sans-serif; font-weight: bold; color: rgb(0, 0, 255);">C++/Tcl</span></font><br>
      <span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 255); font-weight: bold;">A
C++ library for interoperability between C++ and Tcl</span> </td>
      <td style="vertical-align: top; text-align: right;"><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
[<a href="classes.html">prev</a>][<a href="index.html">top</a>][<a
 href="callpolicies.html">next</a>]<br>
<h4>Objects and Lists</h4>
Tcl objects are wrapped by full-fledged C++ objects in cpptcl.  This wrapper provides all sorts of ways to manipulate Tcl objects that have a nice C++ feel while still letting you deal with Tcl stuff in a Tcl way, such as lists, variables, arrays, etc.
<p>
The class <code>object</code> provides the following members:
<p>
1. Constructors
<p>
<div style="margin-left: 40px;"><code>object();<br>
explicit object(bool b);</code><br>
<code>object(char const *buf, size_t size);</code><br>
<code>explicit object(double b);</code><br>
<code>explicit object(int i);</code><br>
<code></code><br>
<code>template &lt;class InputIterator&gt;</code><br>
<code>object(InputIterator first, InputIterator last);</code><br>
<code></code><br>
<code>explicit object(long i);</code><br>
<code>explicit object(char const *s);</code><br>
<code>explicit object(std::string const &amp;s);</code><br>
<code></code></div>
<br>
The above constructors provides the means of creating Tcl objects from common C++ types.
<p>
The constructor accepting iterators is for the list creation. The
provided iterator type should give either <code>object</code> or <code>Tcl_Obj*</code>
type when dereferenced.
<p>
2. Copy constructors
<p>
<div style="margin-left: 40px;"><code>explicit object(Tcl_Obj *o, bool
shared = false);</code><br>
<code>object(object const &amp;other, bool shared = false);<br>
</code><code></code></div>
<p>
If the <code>shared</code> flag is set, the newly created object
wrapper will not duplicate the underlying Tcl object.
<p>
3. Assignment-related members
<p>
<div style="margin-left: 40px;"><code>object &amp; assign(bool b);</code><br>
<code>object &amp; resize(size_t
size);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// byte array resize</code><br>
<code>object &amp; assign(char const *buf, size_t size); // byte array
assignment</code><br>
<code>object &amp; assign(double d);</code><br>
<code>object &amp; assign(int i);</code><br>
<code></code><br>
<code> template &lt;class InputIterator&gt;</code><br>
<code>object &amp; assign(InputIterator first, InputIterator last);</code><br>
<code></code><br>
<code>object &amp; assign(long l);</code><br>
<code>object &amp; assign(char const *s);</code><br>
<code>object &amp; assign(std::string const &amp;s);</code><br>
<code>object &amp; assign(object const &amp;o);<br>
object &amp; assign(Tcl_Obj *o);<br>
</code><code></code><br>
<code>object &amp; operator=(bool b);</code><br>
<code>object &amp; operator=(double d);</code><br>
<code>object &amp; operator=(int i);</code><br>
<code>object &amp; operator=(long l);</code><br>
<code>object &amp; operator=(char const *s);</code><br>
<code>object &amp; operator=(std::string const &amp;s);</code><br>
<code></code><br>
<code>object &amp; operator=(object const &amp;o);</code><br>
<code>object &amp; swap(object &amp;other);</code><br>
<code></code></div>
<p>
The <code>assign</code> member function accepting iterators is for the
list assignment. The provided iterator type should give either <code>object</code>
or <code>Tcl_Obj*</code> type when dereferenced.<br>
<p>
4. Non-modifying accessors
<p>
<div style="margin-left: 40px;"><code>template &lt;typename T&gt;</code><br>
<code>T get(interpreter &amp;i = *interpreter::defaultInterpreter) const;</code><br>
<code></code><br>
<code>char const * get()
const;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// string get</code><br>
<code>char const * get(size_t &amp;size) const; // byte array get</code><br>
<code></code><br>
<code>size_t size(interpreter &amp;i = *interpreter::defaultInterpreter) const;&nbsp; // returns list
length</code><br>
<code>object at(size_t index, interpreter &amp;i = *interpreter::defaultInterpreter) const;</code><br>
<code></code><br>
<code>Tcl_Obj * get_object() const { return obj_; }</code><br>
<code></code></div>
<br>
The <code>get&lt;T&gt;</code> template is specialized for the
following types:<br>
<ul>
  <li><code>bool</code></li>
  <li><code>vector&lt;char&gt;</code> (for byte array queries)</li>
  <li><code>double</code></li>
  <li><code>int</code></li>
  <li><code>long</code></li>
  <li><code>char const *</code></li>
  <li><code>std::string</code><br>
  </li>
</ul>
For ease of use in addition to the <code>get&lt;T&gt;</code> templates there are "asXXX()" chain methods for accessing values with type conversion:
<code>asString(), asInt(), asBool(), asLong() and asDouble()</code>.
<br>
<br>
5. List-related modifiers<br>
<br>
<div style="margin-left: 40px;"><code>object &amp; append(interpreter
&amp;i, object const &amp;o);</code><br>
<code>object &amp; append_list(interpreter &amp;i, object const &amp;o);</code><br>
<code></code><br>
<code>template &lt;class InputIterator&gt;</code><br>
<code>object &amp; replace(Interpreter &amp;i, size_t index, size_t
count,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; InputIterator first, InputIterator last);</code><br>
<code></code><br>
<code>object &amp; replace(interpreter &amp;i, size_t index, size_t
count, object const &amp;o);</code><br>
<code>object &amp; replace_list(interpreter &amp;i, size_t index,
size_t
count, object const &amp;o);</code><br>
<code></code></div>
<br>
6. Interpreter helpers<br>
<br>
All methods have a default interpreter parameter. TCL is a multiple interpreter platform, but many programs only use a single interpreter.
The first created interpreter will be cached as the "default interpreter".  This will be provided as a default parameter to get and set methods
for object types.
<br>
<div style="margin-left: 40px;"><code>void set_interp(Tcl_Interp
*interp);</code><br>
<code>Tcl_Interp * get_interp() const;</code><br>
<code></code></div>
<p>
These functions may help to transmit the information about the
"current" interpreter when the C++ function accepting <code>object</code>
parameter is called from Tcl.
<p>
The <code>set_interp</code> function is automatically called by the underlying
conversion logic, so that the C++ code can use the other function for
accessing the interpreter.
<p>
This may be useful when the C++ code needs to invoke other functions that may change the interpreter state.
<p>
Note: If there is any need to extract the interpreter from the existing
object, it may be helpful to wrap the resulting raw pointer into the <code>interpreter</code>
object, which will not disrupt its normal lifetime:
<p>
<div style="margin-left: 40px;"><code>interpreter i(o.get_interp(),
false);</code><br>
</div>
<p>
The second parameter given to the <code>interpreter</code> constructor
means that the newly created <code>i</code> object will not claim
ownership to the pointer received from <code>get_interp()</code>.
<p>
In other words, the destructor of the object <code>i</code> will not
free the actual interpreter.
<p>
<span style="font-weight: bold;">Example:</span><br>
<p>
The following complete program creates the list of numbers, sorts it
using the Tcl interpreter and prints the results on the console (note:
this is not the most efficient way to sort numbers in C++!):
<p>
<div style="margin-left: 40px;">
<code></code><br>
<code>#include "cpptcl/cpptcl.h"</code><br>
<code>#include &lt;iostream&gt;</code><br>
<code></code><br>
<code>using namespace std;</code><br>
<code>using namespace Tcl;</code><br>
<code></code><br>
<code>int main()</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; interpreter i;</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; int numbers[] = {5, 7, 1, 6, 3, 9, 7};</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; size_t elems = sizeof(numbers) /
sizeof(int);</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; object tab;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; for (size_t indx = 0; indx != elems;
++indx)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tab.append(i, object(numbers[indx]));</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; }</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; object cmd("lsort -integer");</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; cmd.append(i, tab);</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; // here, cmd contains the following:</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; // lsort -integer {5 7 1 6 3 9 7}</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; object result = i.eval(cmd);</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "unsorted: ";</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; for (size_t indx = 0; indx != elems;
++indx)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout
&lt;&lt; numbers[indx] &lt;&lt; ' ';</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; }</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "\n&nbsp; sorted: ";</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; elems = result.size();</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; for (size_t indx = 0; indx != elems;
++indx)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object
obj(result.at(indx));</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int val =
obj.get&lt;int&gt;(); // or obj.asInt() </code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout
&lt;&lt; val &lt;&lt; ' ';</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; }</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; '\n';</code><br>
<code>}</code><br>
<code></code></div>
<br>
When this program is run, it gives the following output:<br>
<br>
<div style="margin-left: 40px;"><code>$ ./example6</code><br>
<code>unsorted: 5 7 1 6 3 9 7 </code><br>
<code>&nbsp; sorted: 1 3 5 6 7 7 9 </code><br>
<code>$ </code><br>
<code></code></div>
<br>
In this example, an empty <code>tab</code> object is created and all
numbers are appended to it to form a Tcl list of numbers.
<p>
After that, the sorting command is composed and executed (as you see,
the <code>object</code> can be passed for evaluation).
<p>
The result of the command is retrieved also in the form of object
wrapper, which is used to decompose the resulting list into its
elements.
<p>
[<a href="classes.html">prev</a>][<a href="index.html">top</a>][<a
 href="callpolicies.html">next</a>]<br>
<br>
<hr style="width: 100%; height: 2px;">Copyright &copy; 2004-2006, Maciej Sobczak<br>
<hr style="width: 100%; height: 2px;">Copyright &copy; 2017-2018, FlightAware LLC<br>
<br>
</body>
</html>
